
\begin {curious}
 It is an amusing question to ask, whether there are other objects, which we did not intend to, which also satisfies the axioms that we wrote, by accident. Say for example, we wrote the axioms for graphs, but "strings" also satisfies them. If so, the theorems that we prove for graphs using only those axioms will also be true for strings, automatically !!. Quite interestingly this is true for natural numbers. The mathematical theory of natural numbers is axiomatized by what are called the Peano's axioms. There are numbers that one can define which are different from natural numbers for which any theorem that we prove for natural numbers also are true (because they satisfy the Peano's axioms). Then one might ask, are we not trying to represent exactly natural numbers? So should we not augment Peano's axioms with more properties of natural numbers such that we remove such {\em unwanted} parallel models from satisfying the axioms we write. Even more interestingly, one can argue that this is not even possible. No matter, what extra formula we write the existence of such "parallel models" us inevitable. In fact, not just one "parallel model", there will be infintiely many of them. You should read about {\em L\"owenheimâ€“Skolem theorem}.
\end {curious}


\begin {curious}
 The formal proof of PHP as simple as it sounds is still a subject of substantial research in an area called \textit {proof complexity}. To demonstrate this, let us write the principle itself in more rigorous notations. Let $n > k$, and $\{ x_{ij} \mid i \in [n], j \in [k] \}$ be propositional variables (which can be called, say {\em pigeon hole variables}). Following our original notation, where there are $n$ pigeons and $k$ holes, the basic Pigeon Hole Principle is the following Disjunctive normal form formula : $$\textrm {\sc PHP}_k^n \defn \left ( \bigvee _{i \in [n]} \bigwedge _{j \in [k]} \bar {x_{ij}} \right ) \lor \left ( \bigvee _{j \in [k]} \bigvee _{r \ne s \in [n]} (x_{rj} \land x_{sj}) \right ) $$ To prove this, one possibility is to derive the contradiction from the negation of $\textrm {\sc PHP}_k^n$. This is an expression in conjunctive normal form, with clauses: $$ \textrm {For $i \in [n]$ the clauses : } Q_i \defn \bigvee _{j=1}^k x_{ij} $$ $$\textrm { and for $s \ne t \in [n], j \in [k]$ the clauses } Q_{s,t,j} \defn \bar {x_{sj}} \lor \bar {x_{tj}}$$ Intuitively, these say that there is a function from $[n] \to [k]$ (which is represented by $x_{ij}=1$ to mean that the function takes $i$ to $j$) which is well defined (for every $i$, there exists a $j$ such that $x_{ij} = 1$) and also injective (for two different $s$ and $t$, it is not the case that $x_{si}$ is $1$ and $x_{tj}$). Since $n > k$, there cannot be an injection, and hence the negation of the conjunction of these clauses $\textrm {\sc PHP}_k^n$ must be true. \par Suppose we ask, starting from these clauses as axioms, and applying rules of inferences (say the resolution principle) alone, how many steps of proof does one need to do to derive the contradiction ($r \land \lnot r$ for some $r$). \footnote {Notice that this sounds exactly like computation, how many steps of computation is required in order to certain tasks in terms of input parameters}. We measure this in terms of $n$ and $k$ which determines the number of variables in the system. The area which studies the complexity of proofs in the above is called {\em proof complexity theory}. It turns out the the basic PHP itself is one of the tautologies for which one requires exponentially long proofs if we are restricting ourselves to resolution? What if we relax this? The area has several interesting open questions related to this and they have close connections to computational complexity theory too.
\end {curious}

